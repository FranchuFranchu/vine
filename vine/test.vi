
fn replace(&self, value) {
  let old = self;
  self = value;
  old
}

fn swap(&a, &b) {
  (a, b) = (b, a)
}

enum Option {
  Some(value),
  None,
}

mod Option {
  fn Some(value) { fn(some, none) { some(value) } }
  fn None(value) { fn(some, none) { none } }
}

mod Option {
  fn map(&move self, f) {
    match self {
      Some(val) => Some(f(val)),
      None => None,
    }
  }

  fn as_ref(&self, f) {
    match self {
      Some(val) => Some(&val),
      None => None,
    }
  }

  fn flatten(&move self) {
    match self {
      Some(Some(val)) => Some(val),
      _ => None,
    }
  }

  fn and_then(&move self, f) {
    self.map(f).flatten()
  }

  fn or(&move self, default) {
    match self {
      None => default,
      x => x,
    }
  }

  fn unwrap_or(&move self, default) {
    match self {
      Some(val) => val,
      None => default,
    }
  }

  fn is_some(&self) {
    match self {
      Some(_) => true,
      None => false,
    }
  }

  fn is_none(&self) {
    match self {
      Some(_) => false,
      None => true,
    }
  }

  fn is_some_and(&self, f) {
    match self {
      Some(val) => f(&val),
      None => false,
    }
  }

  fn is_none_or(&self, f) {
    match self {
      Some(val) => f(&val),
      None => true,
    }
  }
}

struct List(len, buf);

fn List(len, buf) { (len, buf) }

mod List {
  fn len(&self) { &self.p0 }
  fn buf(&self) { &self.p1 }
}

mod List {
  const empty = (0, fn(x) x);

  fn single(el) {
    (1, fn(x) (el, x))
  }

  fn concat(a, b) {
    List(a.len + b.len, fn(x) (a.buf)((b.buf)(x)))
  }
}

struct String(list);

fn String(list) { list }

fn portal() {
  let val;
  (&val, val)
}

mod String {
  const empty = String(List::empty);

  fn char(char) {
    String(List::single(char))
  }

  fn concat(a, b) {
    String(List::concat(a, b))
  }
}

fn precedence() {
  1 + 2 * 3 / 4 - 5 == 6 && 7 & 8 < 9 < 10
}

mod IO {
  fn write_char(&self, char) {
    self = intrinsics::io_write_char(self, char)
  }

  fn flush(&self) {
    self = intrinsics::io_flush(self, 0)
  }

  fn println(&self, str) {
    let buf = (str.String::buf)(_);
    for i in 0..str.String::len {
      let (char, rest) = buf;
      buf = rest;
      self.write_char(char);
    }
    self.write_char('\n');
    self.flush();
  }
}

use std::IO::println;
use std::usize;

fn main(&io) {
  let a = 0;
  let b = 1;
  for i in 0..=32 {
    io.println("fib(" ++ usize::to_string(i) ++ ") = " ++ usize::to_string(a));
    (a, b) = (b, a + b);
  }
}
